<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KIIN ì‚¬ë‹¤ë¦¬ê²Œì„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #080811; overflow: hidden; font-family: 'Malgun Gothic', sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui-panel { position: absolute; top: 20px; left: 20px; width: 340px; z-index: 10; background: rgba(15, 15, 25, 0.85); padding: 20px; border-radius: 12px; border: 1px solid #0ff; backdrop-filter: blur(8px); box-shadow: 0 0 20px rgba(0,255,255,0.2); transition: transform 0.4s ease-in-out; max-height: 95vh; overflow-y: auto; }
        
        #leaderboard { position: absolute; top: 20px; right: 20px; width: 260px; z-index: 10; background: rgba(15, 15, 25, 0.6); padding: 15px; border-radius: 12px; border: 1px solid rgba(0, 255, 255, 0.4); backdrop-filter: blur(4px); color: white; display: none; text-shadow: 1px 1px 2px #000; }
        
        #gravity-warning { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; color: #ff0055; font-size: 80px; font-weight: 900; text-shadow: 0 0 20px #ff0055, 0 0 40px #ff0055; display: none; text-align: center; pointer-events: none; }
        
        #result-modal { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.85); z-index: 50; display: none; flex-direction: column; justify-content: center; align-items: center; backdrop-filter: blur(10px); }
        .result-box { background: linear-gradient(135deg, #1a1a2e, #16213e); border: 2px solid #0ff; border-radius: 20px; padding: 40px; width: 500px; max-width: 90%; text-align: center; box-shadow: 0 0 40px rgba(0,255,255,0.3); animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .loser-name { color: #ff0055; font-size: 2rem; font-weight: 900; text-shadow: 0 0 10px #ff0055; margin: 10px 0; }
        
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        .neon-text { color: #fff; text-shadow: 0 0 5px #fff, 0 0 15px #0ff, 0 0 30px #0ff; }
        .btn-neon { background: linear-gradient(45deg, #00f2fe, #4facfe); border: none; color: white; padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer; transition: 0.2s; width: 100%; text-transform: uppercase; }
        .btn-neon:hover { transform: scale(1.02); }
        .btn-reset { background: linear-gradient(45deg, #ff0844, #ffb199); margin-top: 10px; border: 1px solid #ff0844; }
        
        input { width: 100%; padding: 10px; margin: 10px 0; background: #1a1a24; border: 1px solid #0ff; color: #fff; border-radius: 8px; outline: none; }
        
        .rank-item { padding: 8px; margin-bottom: 5px; border-radius: 6px; background: rgba(255,255,255,0.05); display: flex; justify-content: space-between; align-items: center; font-weight: bold; border-left: 2px solid transparent; }
        .rank-1 { background: linear-gradient(90deg, rgba(255,215,0,0.3), transparent); border-left: 4px solid gold; margin-left: 5px; }
        .rank-2 { background: linear-gradient(90deg, rgba(192,192,192,0.3), transparent); border-left: 4px solid silver; }
        .rank-3 { background: linear-gradient(90deg, rgba(205,127,50,0.3), transparent); border-left: 4px solid #cd7f32; }

        .item-desc { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 0.85rem; }
        .item-icon { font-size: 1.2rem; min-width: 25px; text-align: center; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <h1 class="text-4xl font-black mb-1 neon-text text-center italic tracking-wider">KIIN<br><span class="text-2xl">ì‚¬ë‹¤ë¦¬ê²Œì„</span></h1>
        
        <label class="text-cyan-300 text-sm font-bold mt-4 block">ì°¸ê°€ì (ì‰¼í‘œë¡œ êµ¬ë¶„)</label>
        <input type="text" id="players-input" value="ì² ìˆ˜, ì˜í¬, ë¯¼ìˆ˜, ì§€ì˜, ë™í•´, ë°±ë‘, í•œë¼, íƒœë°±, ê´‘ê°œí† , ì„¸ì¢…" placeholder="ì°¸ê°€ì ì…ë ¥">
        
        <button id="start-btn" class="btn-neon">ğŸš€ ë ˆì´ì‹± ì‹œì‘!</button>
        <button id="reset-btn" class="btn-neon btn-reset">ë§µ ë¬´ì‘ìœ„ ìƒì„± (ìƒˆë¡œê³ ì¹¨)</button>

        <div class="mt-6 bg-gray-900/80 p-4 rounded-lg border border-gray-700 text-gray-300">
            <h3 class="text-yellow-400 font-bold mb-3 border-b border-gray-700 pb-1">ğŸ“š ê²Œì„ ê¸°ë¯¹ ì„¤ëª…</h3>
            <div class="item-desc"><span class="item-icon">â“</span> <span>ë¬´ì§€ê°œ ìƒì (ëœë¤ ëŸ­í‚¤ë°•ìŠ¤)</span></div>
            <div class="pl-8 mb-2 space-y-1 text-xs text-gray-400">
                <p>â–¶ ğŸ„ <b>ê±°ëŒ€í™”:</b> í¬ê¸°ì™€ ë¬´ê²Œ 2.5ë°° ë»¥íŠ€ê¸°</p>
                <p>â–¶ ğŸ­ <b>ì´ˆì†Œí˜•í™”:</b> ì¡°ê·¸ë§£ê³  ë‚ ìŒ”ê²Œ ë³€ì‹ </p>
                <p>â–¶ ğŸ¥¶ <b>ì–¼ìŒ:</b> 2ì´ˆê°„ ê½ê½ ì–¼ì–´ë¶™ì–´ ì •ì§€</p>
            </div>
            <div class="item-desc"><span class="item-icon">âŒ</span> <span><b>ì§€ë¢°:</b> ì£¼ë³€ êµ¬ìŠ¬ë“¤ì„ ì‚¬ë°©ìœ¼ë¡œ ë‚ ë ¤ë²„ë¦¼</span></div>
            <div class="item-desc"><span class="item-icon">ğŸ•³ï¸</span> <span><b>ë©”ê°€ ë¸”ë™í™€:</b> ë¹¨ì•„ë“¤ì—¬ ë¹™ê¸€ë¹™ê¸€ ëŒë¦¼</span></div>
            <div class="item-desc"><span class="item-icon">âš ï¸</span> <span><b>ë¹¨ê°„ ìŠ¤ìœ„ì¹˜:</b> 1ë“±ì´ í†µê³¼í•˜ë©´ <b>ì¤‘ë ¥ ë°˜ì „!</b></span></div>
            <div class="item-desc mt-3 text-cyan-300 font-bold"><span class="item-icon">â˜•</span> <span><b>ë²Œì¹™:</b> ì´ ì¸ì›ì˜ 1/4 (ì†Œìˆ˜ì  ë²„ë¦¼) ë‹¹ì²¨!</span></div>
        </div>
    </div>

    <div id="leaderboard">
        <h2 class="text-xl font-bold mb-3 text-cyan-300 border-b border-gray-600 pb-2">ğŸ† ì‹¤ì‹œê°„ ë­í‚¹</h2>
        <div id="rank-list"></div>
    </div>

    <div id="gravity-warning">GRAVITY<br>REVERSED!!</div>

    <div id="result-modal">
        <div class="result-box">
            <h2 class="text-4xl font-black text-yellow-400 mb-2">ğŸ‰ ë ˆì´ì‹± ì¢…ë£Œ! ğŸ‰</h2>
            <p class="text-gray-300 mb-6 border-b border-gray-600 pb-4">ì¹˜ì—´í•œ ìŠ¹ë¶€ê°€ ëë‚¬ìŠµë‹ˆë‹¤.</p>
            
            <h3 class="text-3xl font-bold text-white mb-4">â˜• ë‹¹ì²¨! â˜•</h3>
            <div id="losers-list" class="bg-gray-800/50 p-4 rounded-lg border border-red-500 mb-6"></div>
            
            <button onclick="closeResult()" class="btn-neon mt-4" style="background: linear-gradient(45deg, #11998e, #38ef7d);">ë‹¤ì‹œ í•˜ê¸° (ë§µ ì´ˆê¸°í™”)</button>
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

    <script>
        const Engine = Matter.Engine,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite,
              Constraint = Matter.Constraint,
              Events = Matter.Events;

        let engine, runner, world;
        let marbles = [];
        let particles = [];
        let finishedMarbles = [];
        let sweepers = []; 
        let mines = [];
        let luckyBoxes = [];
        let gravitySwitch = null;
        let blackholes = [];
        
        const MAP_WIDTH = 1600;
        const MAP_HEIGHT = 12000;
        const FINISH_LINE = MAP_HEIGHT - 300;
        
        let cameraY = 0;
        let cameraZoom = 1; 
        
        let isGravityReversed = false;
        let gravityTimer = 0;
        const GRAVITY_DURATION = 180; 
        const BASE_GRAVITY = 1.8;
        
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // ì•ŒíŒŒ ì±„ë„ ë¹„í™œì„±í™”ë¡œ ë Œë”ë§ ì„±ëŠ¥ ìµœì í™”
        const colors = ['#00ffff', '#ff00ff', '#00ff00', '#ffff00', '#ff5500', '#0088ff', '#ff0055', '#aaff00', '#ffffff', '#ff8800', '#ffb0b0', '#b0ffb0'];

        let frameCounter = 0; // ë­í‚¹ ì—…ë°ì´íŠ¸ ìµœì í™”ë¥¼ ìœ„í•œ ì¹´ìš´í„°

        function init() {
            engine = Engine.create();
            engine.enableSleeping = true; 
            world = engine.world;
            world.gravity.y = BASE_GRAVITY; 

            handleResize();
            window.addEventListener('resize', handleResize);

            buildMap();

            runner = Runner.create({ isFixed: true, delta: 1000 / 60 });
            Runner.run(runner, engine);

            Events.on(engine, 'collisionStart', handleCollisions);
            Events.on(engine, 'collisionActive', handleActiveCollisions);
            Events.on(engine, 'beforeUpdate', updateLogic); 

            requestAnimationFrame(render);
        }

        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cameraZoom = Math.min(1.0, Math.max(0.3, window.innerWidth / (MAP_WIDTH + 400)));
        }

        function buildMap() {
            Composite.clear(world);
            Engine.clear(engine);
            marbles = [];
            finishedMarbles = [];
            particles = [];
            sweepers = [];
            mines = [];
            luckyBoxes = [];
            blackholes = [];
            gravitySwitch = null;
            cameraY = 0;
            isGravityReversed = false;
            world.gravity.y = BASE_GRAVITY;
            document.getElementById('gravity-warning').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';
            document.getElementById('result-modal').style.display = 'none';

            const wallOpts = { isStatic: true, label: 'wall', friction: 0, restitution: 0.6 };
            let elements = [
                Bodies.rectangle(-50, MAP_HEIGHT/2, 100, MAP_HEIGHT + 1000, wallOpts),
                Bodies.rectangle(MAP_WIDTH + 50, MAP_HEIGHT/2, 100, MAP_HEIGHT + 1000, wallOpts),
                Bodies.rectangle(MAP_WIDTH/2, MAP_HEIGHT + 100, MAP_WIDTH, 200, wallOpts)
            ];

            for(let y = 800; y < MAP_HEIGHT - 1000; y += 700) {
                elements.push(Bodies.rectangle(50, y, 300, 40, { isStatic: true, angle: Math.PI/5, friction: 0, restitution: 0.8, label: 'wall', chamfer: {radius: 15} }));
                elements.push(Bodies.rectangle(MAP_WIDTH - 50, y + 350, 300, 40, { isStatic: true, angle: -Math.PI/5, friction: 0, restitution: 0.8, label: 'wall', chamfer: {radius: 15} }));
            }

            const numSticks = 4 + Math.floor(Math.random() * 4); 
            let currentY = 300;
            for (let i = 0; i < numSticks; i++) {
                let isLeft = Math.random() > 0.5;
                let width = 400 + Math.random() * 500;
                let xOffset = (Math.random() * 200) * (isLeft ? -1 : 1);
                let x = (MAP_WIDTH / 2) + (isLeft ? -200 : 200) + xOffset;
                let angle = (0.15 + Math.random() * 0.3) * (isLeft ? 1 : -1);
                
                let rect = Bodies.rectangle(x, currentY, width, 40, { 
                    isStatic: true, angle: angle, friction: 0, restitution: 0.3, label: 'wall', chamfer: { radius: 20 }
                });
                elements.push(rect);
                
                if (Math.random() > 0.4) {
                    let mineX = isLeft ? x + width/2 - 40 : x - width/2 + 40;
                    let mine = Bodies.circle(mineX, currentY - 30, 20, { isStatic: true, isSensor: true, label: 'mine' });
                    elements.push(mine); mines.push(mine);
                }
                currentY += 250 + Math.random() * 200; 
            }

            let seesawY = currentY + 300;
            const numSeesaws = 2 + Math.floor(Math.random() * 3);
            for(let i = 0; i < numSeesaws; i++) {
                let x = MAP_WIDTH/2 + (Math.random() * 600 - 300); 
                let width = 400 + Math.random() * 300;
                let seesaw = Bodies.rectangle(x, seesawY, width, 40, { friction: 0, restitution: 0.2, label: 'seesaw', chamfer: { radius: 20 }});
                Matter.Body.setAngle(seesaw, (Math.random() * 0.4 - 0.2)); 
                let pivot = Constraint.create({ pointA: {x: x, y: seesawY}, bodyB: seesaw, length: 0, stiffness: 0.9, render: { visible: false } });
                
                elements.push(seesaw, pivot);
                elements.push(Bodies.circle(x - width/2 + 20, seesawY - 50, 15, { isStatic: true, label: 'pin' }));
                elements.push(Bodies.circle(x + width/2 - 20, seesawY - 50, 15, { isStatic: true, label: 'pin' }));

                if (Math.random() > 0.3) {
                    let boxX = x + (Math.random() * (width/2) - width/4);
                    let box = Bodies.rectangle(boxX, seesawY - 60, 50, 50, { isStatic: true, isSensor: true, label: 'lucky_box', chamfer: {radius: 8} });
                    elements.push(box); luckyBoxes.push(box);
                }
                seesawY += 350 + Math.random() * 200;
            }

            let sweeperY = seesawY + 300;
            while(sweeperY < 7000) {
                let width = 300 + Math.random() * 200;
                let sweeper = Bodies.rectangle(MAP_WIDTH/2, sweeperY, width, 40, { isStatic: true, friction: 0, restitution: 0.8, label: 'wall', chamfer: { radius: 20 } });
                elements.push(sweeper);
                sweepers.push({ body: sweeper, startX: MAP_WIDTH/2, range: 300 + Math.random()*200, angle: Math.random() * Math.PI, speed: 0.03 + Math.random()*0.04 });
                
                if (Math.random() > 0.5) {
                    let mine = Bodies.circle(MAP_WIDTH/2 + (Math.random() * 600 - 300), sweeperY + 150, 20, { isStatic: true, isSensor: true, label: 'mine' });
                    elements.push(mine); mines.push(mine);
                }
                sweeperY += 350 + Math.random()*250;
            }

            const numBlackholes = 2 + Math.floor(Math.random() * 2);
            let bhY = sweeperY + 200;
            for(let i=0; i<numBlackholes; i++) {
                let bhX = MAP_WIDTH/2 + (Math.random() * 600 - 300);
                let radius = 450 + Math.random() * 300;
                let power = 0.004 + Math.random() * 0.003;
                createBlackhole(elements, bhX, bhY, radius, power);
                
                if(Math.random() > 0.3){
                    let box1 = Bodies.rectangle(bhX + (Math.random()>0.5?300:-300), bhY, 50, 50, { isStatic: true, isSensor: true, label: 'lucky_box', chamfer: {radius: 8} });
                    elements.push(box1); luckyBoxes.push(box1);
                }
                bhY += radius + 300;
            }

            for(let i=0; i < 5 + Math.floor(Math.random()*4); i++) {
                let x = 300 + Math.random() * (MAP_WIDTH - 600);
                let y = 6000 + Math.random() * 3000;
                let width = 200 + Math.random() * 150;
                let pad = Bodies.rectangle(x, y, width, 30, { isStatic: true, isSensor: true, label: 'boost', chamfer: { radius: 10 } });
                elements.push(pad);
            }

            let switchY = 10400 + Math.random() * 200;
            gravitySwitch = Bodies.rectangle(MAP_WIDTH/2, switchY, MAP_WIDTH, 60, { isStatic: true, isSensor: true, label: 'gravity_switch' });
            elements.push(gravitySwitch);

            for (let y = 9000; y < 11200; y += (200 + Math.random()*50)) {
                if (Math.abs(y - switchY) < 150) continue; 
                
                let offset = Math.random() * 100;
                let gap = 180 + Math.random() * 60;
                for (let x = 100; x < MAP_WIDTH - 50; x += gap) {
                    if (Math.random() > 0.2) {
                        elements.push(Bodies.circle(x + offset, y, 18, { isStatic: true, restitution: 0.6, label: 'pin' }));
                    } else if (Math.random() > 0.8) {
                        let mine = Bodies.circle(x + offset, y, 20, { isStatic: true, isSensor: true, label: 'mine' });
                        elements.push(mine); mines.push(mine);
                    }
                }
            }

            const numSlots = 10;
            const slotWidth = MAP_WIDTH / numSlots;
            for (let i = 1; i < numSlots; i++) {
                let dividerX = i * slotWidth;
                let dividerY = MAP_HEIGHT - 300;
                let divider = Bodies.rectangle(dividerX, dividerY, 20, 600, { isStatic: true, restitution: 0.5, label: 'wall' });
                let cap = Bodies.circle(dividerX, dividerY - 300, 10, { isStatic: true, restitution: 0.5, label: 'wall' });
                elements.push(divider, cap);
            }

            Composite.add(world, elements);
        }

        function createBlackhole(elementsArray, x, y, radius, power) {
            let bhSensor = Bodies.circle(x, y, radius, { isStatic: true, isSensor: true, label: 'blackhole_sensor' });
            let bhCore = Bodies.circle(x, y, radius * 0.1, { isStatic: true, restitution: 0.8, friction: 0, label: 'blackhole_core' });
            elementsArray.push(bhSensor, bhCore);
            blackholes.push({ x: x, y: y, radius: radius, power: power, rotation: 0 });
        }

        function startRace(playerNames) {
            if(marbles.length > 0) buildMap();
            
            document.getElementById('ui-panel').style.transform = 'translateY(-150%)';
            document.getElementById('leaderboard').style.display = 'block';

            playerNames.forEach((name, i) => {
                const color = colors[i % colors.length];
                const startX = (MAP_WIDTH / 2) + (Math.random() * 400 - 200);
                const startY = -200 - (i * 120); 
                
                const marble = Bodies.circle(startX, startY, 24, { 
                    restitution: 0.6, friction: 0.001, frictionAir: 0.015, density: 0.05,
                    label: 'marble',
                    plugin: { 
                        name: name, color: color, trail: [], finished: false, stopped: false, rank: 0, currentRank: 0,
                        stuckTimer: 0, effect: 'none', effectTimer: 0, baseRadius: 24
                    }
                });
                
                Body.setVelocity(marble, { x: (Math.random() - 0.5) * 10, y: 5 });
                marbles.push(marble);
                Composite.add(world, marble);
            });
        }

        function triggerMine(mineBody, triggerMarble) {
            Body.setPosition(mineBody, { x: -1000, y: -1000 });
            createParticles(mineBody.position.x, mineBody.position.y, '#ff0055', 40, 30); 
            const explosionRadius = 250;
            const explosionForce = 0.5;
            marbles.forEach(marble => {
                if(marble.plugin.finished) return;
                let dx = marble.position.x - mineBody.position.x;
                let dy = marble.position.y - mineBody.position.y;
                let distSq = dx*dx + dy*dy;
                if (distSq < explosionRadius * explosionRadius) {
                    let dist = Math.sqrt(distSq);
                    let forceMag = explosionForce * (1 - dist/explosionRadius) * marble.mass;
                    Body.applyForce(marble, marble.position, { x: (dx/dist) * forceMag, y: (dy/dist) * forceMag - 0.2 });
                }
            });
        }

        function triggerLuckyBox(boxBody, marble) {
            Body.setPosition(boxBody, { x: -1000, y: -1000 });
            const effects = ['giant', 'mini', 'freeze'];
            const effect = effects[Math.floor(Math.random() * effects.length)];
            marble.plugin.effect = effect;
            
            if (effect === 'giant') {
                marble.plugin.effectTimer = 400; Body.scale(marble, 2.5, 2.5); Body.setDensity(marble, 0.2); 
                createParticles(marble.position.x, marble.position.y, '#ffff00', 30);
            } else if (effect === 'mini') {
                marble.plugin.effectTimer = 400; Body.scale(marble, 0.5, 0.5); Body.setDensity(marble, 0.05); 
                createParticles(marble.position.x, marble.position.y, '#00ffff', 30);
            } else if (effect === 'freeze') {
                marble.plugin.effectTimer = 120; marble.plugin.savedVelocity = { ...marble.velocity };
                Body.setVelocity(marble, {x:0, y:0}); Body.setStatic(marble, true); 
                createParticles(marble.position.x, marble.position.y, '#ffffff', 30);
            }
        }

        function triggerGravitySwitch() {
            if (isGravityReversed) return; 
            isGravityReversed = true;
            gravityTimer = GRAVITY_DURATION;
            world.gravity.y = -BASE_GRAVITY; 
            document.getElementById('gravity-warning').style.display = 'block';
            createParticles(MAP_WIDTH/2, gravitySwitch.position.y, '#ff0000', 100, 50);
        }

        function showResultScreen() {
            const total = marbles.length;
            const numLosers = Math.floor(total / 4);
            const losersList = document.getElementById('losers-list');
            losersList.innerHTML = '';
            
            if (numLosers <= 0) {
                losersList.innerHTML = `<p class="text-white text-lg">ì¸ì›ìˆ˜ê°€ ì ì–´ (4ëª… ë¯¸ë§Œ) ë‹¹ì²¨ìê°€ ì—†ìŠµë‹ˆë‹¤! ğŸ•Šï¸</p>`;
            } else {
                const losers = finishedMarbles.slice(-numLosers);
                losers.reverse().forEach(loser => { 
                    const div = document.createElement('div');
                    div.className = 'loser-name';
                    div.innerHTML = `${loser.plugin.name} <span class="text-sm text-gray-400">(${loser.plugin.rank}ë“±)</span>`;
                    losersList.appendChild(div);
                });
            }
            document.getElementById('result-modal').style.display = 'flex';
        }

        function closeResult() {
            document.getElementById('result-modal').style.display = 'none';
            buildMap();
            document.getElementById('ui-panel').style.transform = 'translateY(0)';
        }

        function updateLogic() {
            sweepers.forEach(s => {
                s.angle += s.speed;
                let nx = s.startX + Math.sin(s.angle) * s.range;
                Body.setPosition(s.body, { x: nx, y: s.body.position.y });
            });

            blackholes.forEach(bh => {
                bh.rotation += 0.08; 
                marbles.forEach(marble => {
                    if (marble.plugin.finished) return;
                    
                    let dx = bh.x - marble.position.x;
                    if (Math.abs(dx) > bh.radius) return;
                    let dy = bh.y - marble.position.y;
                    if (Math.abs(dy) > bh.radius) return;

                    let distSq = dx*dx + dy*dy;
                    if (distSq < bh.radius * bh.radius) {
                        let dist = Math.sqrt(distSq);
                        if (dist > 15) {
                            let massFactor = marble.plugin.effect === 'giant' ? 0.6 : 1.0;
                            let forceMag = bh.power * marble.mass * massFactor * (1 - dist/bh.radius); 
                            let nx = dx / dist; let ny = dy / dist;
                            let vx = nx * 1.5 + ny * 0.8; let vy = ny * 1.5 - nx * 0.8;
                            Body.applyForce(marble, marble.position, { x: vx * forceMag, y: vy * forceMag });
                        }
                    }
                });
            });

            if (isGravityReversed) {
                gravityTimer--;
                if (gravityTimer <= 0) {
                    isGravityReversed = false;
                    world.gravity.y = BASE_GRAVITY; 
                    document.getElementById('gravity-warning').style.display = 'none';
                } else {
                    document.getElementById('gravity-warning').style.opacity = (gravityTimer % 10 < 5) ? 1 : 0.5;
                }
            }

            if (!isGravityReversed && marbles.length > 0) {
                let total = marbles.length;
                marbles.forEach(marble => {
                    if (marble.plugin.finished || marble.plugin.effect === 'freeze') return;
                    let rank = marble.plugin.currentRank;
                    if (rank <= Math.ceil(total * 0.3)) {
                        Body.applyForce(marble, marble.position, { x: 0, y: -0.0003 * marble.mass }); 
                    } 
                    else if (rank >= Math.floor(total * 0.6)) {
                        Body.applyForce(marble, marble.position, { x: 0, y: 0.0004 * marble.mass }); 
                    }
                });
            }

            marbles.forEach(marble => {
                if (marble.plugin.finished) return;

                if (marble.plugin.effect !== 'freeze' && Math.abs(marble.velocity.x) < 0.5 && Math.abs(marble.velocity.y) < 0.5) {
                    marble.plugin.stuckTimer++;
                    if (marble.plugin.stuckTimer > 30) {
                        Body.applyForce(marble, marble.position, {
                            x: (Math.random() - 0.5) * 0.2 * marble.mass,
                            y: (isGravityReversed ? 0.25 : -0.25) * marble.mass 
                        });
                        marble.plugin.stuckTimer = 0;
                    }
                } else {
                    marble.plugin.stuckTimer = 0;
                }

                if (marble.plugin.effect !== 'none') {
                    marble.plugin.effectTimer--;
                    if (marble.plugin.effectTimer <= 0) {
                        if (marble.plugin.effect === 'giant') {
                            Body.scale(marble, 1/2.5, 1/2.5); Body.setDensity(marble, 0.05);    
                        } else if (marble.plugin.effect === 'mini') {
                            Body.scale(marble, 2, 2); 
                        } else if (marble.plugin.effect === 'freeze') {
                            Body.setStatic(marble, false); Body.setVelocity(marble, marble.plugin.savedVelocity);
                        }
                        marble.plugin.effect = 'none';
                        createParticles(marble.position.x, marble.position.y, marble.plugin.color, 20);
                    }
                }
            });
        }

        function handleCollisions(event) {
            event.pairs.forEach(pair => {
                let bodyA = pair.bodyA; let bodyB = pair.bodyB;
                if (bodyA.label === 'blackhole_core' || bodyB.label === 'blackhole_core') {
                    let marble = bodyA.label === 'marble' ? bodyA : (bodyB.label === 'marble' ? bodyB : null);
                    if(marble) createParticles(marble.position.x, marble.position.y, '#a020f0', 5);
                }
            });
        }

        function handleActiveCollisions(event) {
            event.pairs.forEach(pair => {
                let bodyA = pair.bodyA; let bodyB = pair.bodyB;
                let marble = null; let sensor = null;

                if (bodyA.label === 'marble') marble = bodyA;
                else if (bodyB.label === 'marble') marble = bodyB;

                if (!marble) return;

                if (bodyA.isSensor) sensor = bodyA;
                else if (bodyB.isSensor) sensor = bodyB;

                if (sensor) {
                    if (sensor.label === 'boost') {
                        Body.applyForce(marble, marble.position, { x: 0, y: 0.1 * (marble.mass / 0.09) * (isGravityReversed ? -1 : 1) }); 
                    } 
                    else if (sensor.label === 'mine') { triggerMine(sensor, marble); }
                    else if (sensor.label === 'lucky_box' && marble.plugin.effect === 'none') { triggerLuckyBox(sensor, marble); }
                    else if (sensor.label === 'gravity_switch') {
                        triggerGravitySwitch(); Body.setPosition(sensor, {x: -1000, y: -1000}); 
                    }
                }
            });
        }

        function createParticles(x, y, color, count, speed=15) {
            if (particles.length > 200) return; 
            for(let i=0; i<count; i++) particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed, life: 1.0, color: color });
        }

        function createFireworks() {
            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    let fx = MAP_WIDTH/2 + (Math.random() - 0.5) * MAP_WIDTH * 0.8;
                    let fy = FINISH_LINE - 200 - Math.random() * 300;
                    createParticles(fx, fy, colors[Math.floor(Math.random() * colors.length)], 50, 20);
                }, i * 300);
            }
        }

        function render() {
            frameCounter++;

            ctx.fillStyle = isGravityReversed ? '#2b0000' : '#080811';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let leaderY = 0; 
            marbles.forEach(m => {
                if (!m.plugin.finished && m.position.y > leaderY) {
                    leaderY = m.position.y;
                }
            });
            if (leaderY === 0 && finishedMarbles.length > 0) leaderY = MAP_HEIGHT; 

            let viewHeightInWorld = canvas.height / cameraZoom;
            let targetCameraY = leaderY - (viewHeightInWorld * 0.7); 
            
            targetCameraY = Math.max(cameraY, targetCameraY);
            if (targetCameraY < -500) targetCameraY = -500;
            if (targetCameraY > MAP_HEIGHT - viewHeightInWorld + 200) targetCameraY = MAP_HEIGHT - viewHeightInWorld + 200;
            
            cameraY += (targetCameraY - cameraY) * 0.08;

            const viewTop = cameraY - 100;
            const viewBottom = cameraY + viewHeightInWorld + 100;

            ctx.save();
            ctx.translate(canvas.width / 2, 0); 
            ctx.scale(cameraZoom, cameraZoom);
            ctx.translate(-MAP_WIDTH / 2, -cameraY);

            blackholes.forEach(bh => {
                if (bh.y + bh.radius < viewTop || bh.y - bh.radius > viewBottom) return;

                let gradient = ctx.createRadialGradient(bh.x, bh.y, bh.radius * 0.1, bh.x, bh.y, bh.radius);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)'); gradient.addColorStop(0.3, 'rgba(128, 0, 255, 0.4)'); gradient.addColorStop(1, 'rgba(128, 0, 255, 0)');
                ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(bh.x, bh.y, bh.radius, 0, 2 * Math.PI); ctx.fill();

                ctx.save(); ctx.translate(bh.x, bh.y); ctx.rotate(bh.rotation);
                ctx.strokeStyle = 'rgba(200, 100, 255, 0.6)'; ctx.lineWidth = 2;
                for(let i=0; i<8; i++) { ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(bh.radius * 0.6, bh.radius * 0.6, bh.radius, 0); ctx.stroke(); ctx.rotate((Math.PI * 2) / 8); }
                ctx.restore();
                
                ctx.fillStyle = '#000'; ctx.strokeStyle = '#a020f0'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(bh.x, bh.y, bh.radius * 0.1, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            });

            ctx.fillStyle = 'rgba(0, 240, 255, 0.1)'; ctx.strokeStyle = '#00f0ff'; ctx.lineWidth = 2;
            ctx.beginPath();
            world.bodies.forEach(body => {
                if (body.bounds.max.y < viewTop || body.bounds.min.y > viewBottom) return;
                if (body.label === 'wall' || body.label === 'seesaw') {
                    body.parts.forEach((part, i) => {
                        if (i === 0 && body.parts.length > 1) return; 
                        ctx.moveTo(part.vertices[0].x, part.vertices[0].y);
                        for (let j = 1; j < part.vertices.length; j++) ctx.lineTo(part.vertices[j].x, part.vertices[j].y);
                        ctx.lineTo(part.vertices[0].x, part.vertices[0].y);
                    });
                }
            });
            ctx.fill(); ctx.stroke();

            ctx.fillStyle = 'rgba(255, 255, 0, 0.2)'; ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 2; 
            ctx.beginPath();
            world.bodies.forEach(body => {
                if (body.bounds.max.y < viewTop || body.bounds.min.y > viewBottom) return;
                if (body.label === 'pin') {
                    ctx.moveTo(body.position.x + body.circleRadius, body.position.y);
                    ctx.arc(body.position.x, body.position.y, body.circleRadius, 0, 2*Math.PI);
                }
            });
            ctx.fill(); ctx.stroke();

            world.bodies.forEach(body => {
                if (body.bounds.max.y < viewTop || body.bounds.min.y > viewBottom) return;

                if (body.label === 'boost') {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; ctx.strokeStyle = '#0f0'; ctx.lineWidth = 3; 
                    ctx.beginPath(); body.vertices.forEach((v, i) => i===0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath(); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#0f0'; ctx.font = 'bold 30px Arial'; ctx.textAlign = 'center'; ctx.fillText('â†“â†“ BOOST â†“â†“', body.position.x, body.position.y + 10);
                } 
                else if (body.label === 'lucky_box') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.rect(body.bounds.min.x, body.bounds.min.y, 50, 50); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 30px Arial'; ctx.textAlign = 'center'; ctx.fillText('?', body.position.x, body.position.y + 10);
                }
                else if (body.label === 'mine') {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(body.position.x, body.position.y, body.circleRadius, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.fillText('âŒ', body.position.x, body.position.y + 7);
                }
                else if (body.label === 'gravity_switch') {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.3)'; ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.rect(body.bounds.min.x, body.bounds.min.y, body.bounds.max.x - body.bounds.min.x, body.bounds.max.y - body.bounds.min.y); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 45px "Malgun Gothic"'; ctx.textAlign = 'center'; 
                    ctx.fillText('âš ï¸ ì¤‘ë ¥ ë°˜ì „ ì ˆëŒ€ì„  âš ï¸', MAP_WIDTH/2, body.position.y + 15);
                }
            });

            if (FINISH_LINE > viewTop && FINISH_LINE < viewBottom) {
                ctx.beginPath(); ctx.moveTo(0, FINISH_LINE); ctx.lineTo(MAP_WIDTH, FINISH_LINE);
                ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 8; ctx.setLineDash([30, 20]); ctx.stroke(); ctx.setLineDash([]);
                ctx.fillStyle = '#ffff00'; ctx.font = 'bold 60px sans-serif'; ctx.textAlign = 'center'; 
                ctx.fillText('ğŸ† FINISH LINE ğŸ†', MAP_WIDTH/2, FINISH_LINE - 30);
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; 
                p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                if (p.life <= 0) { particles.splice(i, 1); continue; }
                if (p.y >= viewTop && p.y <= viewBottom) {
                    ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 6, 6); 
                }
            }
            ctx.globalAlpha = 1.0;

            if (frameCounter % 15 === 0) {
                updateLeaderboard();
            }

            marbles.forEach(marble => {
                const plugin = marble.plugin;
                
                if (!plugin.finished && marble.position.y > FINISH_LINE) {
                    plugin.finished = true;
                    plugin.rank = finishedMarbles.length + 1;
                    finishedMarbles.push(marble);
                    
                    // [ë³€ê²½ì ] ë°”ë¡œ ë©ˆì¶”ì§€ ì•Šê³  1ì´ˆ(1000ms) ë’¤ì— ë¬¼ë¦¬ ì—°ì‚° ì¢…ë£Œ (ì™„ì „ ì •ì§€)
                    setTimeout(() => {
                        plugin.stopped = true;
                        Body.setStatic(marble, true);
                    }, 1000);

                    createParticles(marble.position.x, marble.position.y, plugin.color, 60);
                    
                    if(finishedMarbles.length === marbles.length) {
                        createFireworks();
                        setTimeout(() => { showResultScreen(); }, 2500);
                    }
                }

                // [ë³€ê²½ì ] ê¼¬ë¦¬ íš¨ê³¼ë„ 1ì´ˆ ë™ì•ˆì€ ê³„ì† ë”°ë¼ì˜¤ê²Œ ë§Œë“¦ (stopped í™•ì¸)
                if (plugin.effect !== 'freeze' && !plugin.stopped) {
                    plugin.trail.push({x: marble.position.x, y: marble.position.y});
                    if (plugin.trail.length > 20) plugin.trail.shift(); 
                }

                if (plugin.trail.length > 1) {
                    let p1 = plugin.trail[0];
                    if (!(p1.y < viewTop - 100 || p1.y > viewBottom + 100)) {
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.lineWidth = marble.circleRadius * 1.2;
                        ctx.strokeStyle = plugin.color;
                        ctx.globalAlpha = 0.4;
                        
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        for (let i = 1; i < plugin.trail.length; i++) {
                            ctx.lineTo(plugin.trail[i].x, plugin.trail[i].y);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                }

                if (marble.position.y >= viewTop - 100 && marble.position.y <= viewBottom + 100) {
                    if (plugin.effect === 'giant') {
                        ctx.beginPath(); ctx.arc(marble.position.x, marble.position.y, marble.circleRadius * 1.3, 0, 2*Math.PI);
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'; ctx.fill();
                    } else if (plugin.effect === 'freeze') {
                        ctx.beginPath(); ctx.arc(marble.position.x, marble.position.y, marble.circleRadius * 1.5, 0, 2*Math.PI);
                        ctx.fillStyle = 'rgba(200, 255, 255, 0.6)'; ctx.fill(); 
                    }

                    ctx.beginPath(); ctx.arc(marble.position.x, marble.position.y, marble.circleRadius, 0, 2*Math.PI);
                    ctx.fillStyle = (plugin.effect === 'freeze') ? '#ccffff' : '#fff'; ctx.fill();
                    ctx.strokeStyle = plugin.color; ctx.lineWidth = 5;
                    ctx.stroke(); 

                    let fontSize = (plugin.effect === 'giant') ? 34 : (plugin.effect === 'mini' ? 16 : 24);
                    ctx.font = `bold ${fontSize}px "Malgun Gothic", sans-serif`;
                    const textWidth = ctx.measureText(plugin.name).width;
                    const badgeWidth = textWidth + 20;
                    const badgeHeight = (plugin.effect === 'giant') ? 40 : (plugin.effect === 'mini' ? 20 : 32);
                    const badgeX = marble.position.x - badgeWidth / 2;
                    const badgeY = marble.position.y - marble.circleRadius - badgeHeight - (plugin.effect === 'giant' ? 15 : 10);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.beginPath(); ctx.rect(badgeX, badgeY, badgeWidth, badgeHeight); ctx.fill(); 
                    ctx.strokeStyle = plugin.color; ctx.lineWidth = 2; ctx.stroke();

                    ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(plugin.name, marble.position.x, badgeY + badgeHeight / 2);
                    
                    if (plugin.finished) {
                        const rankStr = plugin.rank + 'ë“±';
                        ctx.font = '900 36px "Malgun Gothic", sans-serif';
                        const rWidth = ctx.measureText(rankStr).width;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(marble.position.x - rWidth/2 - 15, marble.position.y - marble.circleRadius - 90, rWidth + 30, 45);
                        ctx.fillStyle = 'gold'; ctx.fillText(rankStr, marble.position.x, marble.position.y - marble.circleRadius - 65);
                    }
                }
            });

            ctx.restore();
            requestAnimationFrame(render);
        }

        function updateLeaderboard() {
            if(marbles.length === 0) return;
            let sorted = [...marbles].sort((a, b) => {
                if (a.plugin.finished && b.plugin.finished) return a.plugin.rank - b.plugin.rank;
                if (a.plugin.finished) return -1;
                if (b.plugin.finished) return 1;
                return b.position.y - a.position.y;
            });

            let html = '';
            sorted.forEach((marble, idx) => {
                const rank = idx + 1;
                marble.plugin.currentRank = rank;

                let cssClass = 'rank-item';
                if(rank === 1) cssClass += ' rank-1';
                else if(rank === 2) cssClass += ' rank-2';
                else if(rank === 3) cssClass += ' rank-3';

                let status = marble.plugin.finished ? 'ğŸ ë„ì°©' : Math.floor((marble.position.y / FINISH_LINE) * 100) + '%';
                if(marble.position.y < 0) status = 'ëŒ€ê¸°ì¤‘';

                let icon = '';
                if(marble.plugin.effect === 'giant') icon = 'ğŸ„';
                else if(marble.plugin.effect === 'mini') icon = 'ğŸ­';
                else if(marble.plugin.effect === 'freeze') icon = 'ğŸ¥¶';
                
                if (rank === 1 && !marble.plugin.finished) icon += 'ğŸ‘‘';

                html += `<div class="${cssClass}">
                            <div style="display:flex; align-items:center;">
                                <span style="display:inline-block; width:25px; font-size:1.1em; text-align:center; margin-right:10px; color:#fff;">${rank}</span>
                                <span style="display:inline-block; width:14px; height:14px; border-radius:50%; background-color:${marble.plugin.color}; margin-right:10px;"></span>
                                <span style="color:#fff;">${marble.plugin.name} ${icon}</span>
                            </div>
                            <span class="text-sm" style="color:#ddd;">${status}</span>
                         </div>`;
            });
            document.getElementById('rank-list').innerHTML = html;
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            const players = document.getElementById('players-input').value.split(',').map(p => p.trim()).filter(p => p !== "");
            if (players.length > 0) startRace(players);
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            buildMap();
            document.getElementById('ui-panel').style.transform = 'translateY(0)';
        });

        init();
    </script>
</body>
</html>
