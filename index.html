<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KIIN ì‚¬ë‹¤ë¦¬ê²Œì„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #080811; overflow: hidden; font-family: 'Malgun Gothic', sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui-panel { position: absolute; top: 20px; left: 20px; width: 340px; z-index: 10; background: rgba(15, 15, 25, 0.9); padding: 20px; border-radius: 12px; border: 1px solid #0ff; backdrop-filter: blur(8px); box-shadow: 0 0 20px rgba(0,255,255,0.2); transition: transform 0.4s ease-in-out; max-height: 95vh; overflow-y: auto; }
        #leaderboard { position: absolute; top: 20px; right: 20px; width: 280px; z-index: 10; background: rgba(15, 15, 25, 0.9); padding: 15px; border-radius: 12px; border: 1px solid #0ff; backdrop-filter: blur(8px); color: white; display: none; }
        
        #gravity-warning { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 20; color: #ff0055; font-size: 80px; font-weight: 900; text-shadow: 0 0 20px #ff0055, 0 0 40px #ff0055; display: none; text-align: center; pointer-events: none; }
        
        .neon-text { color: #fff; text-shadow: 0 0 5px #fff, 0 0 15px #0ff, 0 0 30px #0ff; }
        .btn-neon { background: linear-gradient(45deg, #00f2fe, #4facfe); border: none; color: white; padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer; transition: 0.2s; width: 100%; text-transform: uppercase; box-shadow: 0 0 15px rgba(0, 242, 254, 0.4); margin-top: 15px; }
        .btn-neon:hover { transform: scale(1.02); box-shadow: 0 0 25px rgba(0, 242, 254, 0.7); }
        .btn-reset { background: linear-gradient(45deg, #ff0844, #ffb199); margin-top: 10px; box-shadow: 0 0 15px rgba(255, 8, 68, 0.4); border: 1px solid #ff0844; }
        
        input { width: 100%; padding: 10px; margin: 10px 0; background: #1a1a24; border: 1px solid #0ff; color: #fff; border-radius: 8px; outline: none; transition: 0.3s; }
        input:focus { box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); }
        
        .rank-item { padding: 8px; margin-bottom: 5px; border-radius: 6px; background: rgba(255,255,255,0.05); display: flex; justify-content: space-between; align-items: center; font-weight: bold; transition: all 0.3s; }
        .rank-1 { background: linear-gradient(90deg, rgba(255,215,0,0.4), transparent); border-left: 4px solid gold; transform: scale(1.05); margin-left: 5px; }
        .rank-2 { background: linear-gradient(90deg, rgba(192,192,192,0.4), transparent); border-left: 4px solid silver; }
        .rank-3 { background: linear-gradient(90deg, rgba(205,127,50,0.4), transparent); border-left: 4px solid #cd7f32; }
        .rank-loser { background: linear-gradient(90deg, rgba(255,50,50,0.4), transparent); border-left: 4px solid #ff3232; color: #ff8888; }

        .item-desc { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 0.85rem; }
        .item-icon { font-size: 1.2rem; min-width: 25px; text-align: center; }
    </style>
</head>
<body>

    <div id="ui-panel">
        <h1 class="text-4xl font-black mb-1 neon-text text-center italic tracking-wider">KIIN<br><span class="text-2xl">ì‚¬ë‹¤ë¦¬ê²Œì„</span></h1>
        
        <label class="text-cyan-300 text-sm font-bold mt-4 block">ì°¸ê°€ì (ì‰¼í‘œë¡œ êµ¬ë¶„)</label>
        <input type="text" id="players-input" value="ì² ìˆ˜, ì˜í¬, ë¯¼ìˆ˜, ì§€ì˜, ë™í•´, ë°±ë‘, í•œë¼, íƒœë°±, ê´‘ê°œí† , ì„¸ì¢…" placeholder="ì°¸ê°€ì ì…ë ¥">
        
        <div id="penalty-info" class="text-yellow-300 text-sm text-center mt-2 font-bold bg-yellow-900/40 p-2 rounded">
            â˜• ì»¤í”¼ ë‚´ê¸° ë‹¹ì²¨ì: 2ëª… (ìë™ ê³„ì‚°)
        </div>

        <button id="start-btn" class="btn-neon">ğŸš€ ë ˆì´ì‹± ì‹œì‘!</button>
        <button id="reset-btn" class="btn-neon btn-reset">ë§µ ë¬´ì‘ìœ„ ìƒì„± (ìƒˆë¡œê³ ì¹¨)</button>

        <div class="mt-4 bg-gray-900/80 p-4 rounded-lg border border-gray-700 text-gray-300">
            <h3 class="text-yellow-400 font-bold mb-3 border-b border-gray-700 pb-1">ğŸ“š ê²Œì„ ë£° & ê¸°ë¯¹</h3>
            <ul class="text-xs space-y-2">
                <li>ğŸ¯ <b>ì»¤í”¼ ë‹¹ì²¨:</b> (ì´ ì¸ì› Ã· 4) ëª… ê¼´ë“± ë‹¹ì²¨!</li>
                <li>ğŸ§² <b>ê³ ë¬´ì¤„ íš¨ê³¼:</b> í›„ë°˜ë¶€ë¡œ ê°ˆìˆ˜ë¡ ë’¤ì³ì§„ ë§ˆë¸”ë“¤ì˜ ì†ë„ê°€ ë¹¨ë¼ì ¸ ìˆœìœ„ê°€ ì¢í˜€ì§‘ë‹ˆë‹¤.</li>
            </ul>
            <div class="mt-3">
                <div class="item-desc"><span class="item-icon">â“</span> <span><b>ëŸ­í‚¤ë°•ìŠ¤:</b> ê±°ëŒ€í™”/ì´ˆì†Œí˜•í™”/ì–¼ìŒ ëœë¤ ë°œë™</span></div>
                <div class="item-desc"><span class="item-icon">âŒ</span> <span><b>ì§€ë¢°:</b> ì£¼ë³€ êµ¬ìŠ¬ë“¤ì„ ì‚¬ë°©ìœ¼ë¡œ ë‚ ë ¤ë²„ë¦¼</span></div>
                <div class="item-desc"><span class="item-icon">ğŸ•³ï¸</span> <span><b>ë©”ê°€ ë¸”ë™í™€:</b> ë¹¨ì•„ë“¤ì—¬ ë¹™ê¸€ë¹™ê¸€ ëŒë¦¼</span></div>
                <div class="item-desc"><span class="item-icon">âš ï¸</span> <span><b>ë¹¨ê°„ ìŠ¤ìœ„ì¹˜(í›„ë°˜ë¶€):</b> 3ì´ˆê°„ <b>ì¤‘ë ¥ ë°˜ì „!</b></span></div>
            </div>
        </div>
    </div>

    <div id="leaderboard">
        <h2 class="text-xl font-bold mb-3 text-cyan-300 border-b border-gray-600 pb-2">ğŸ† ì‹¤ì‹œê°„ ë­í‚¹</h2>
        <div id="rank-list"></div>
    </div>

    <div id="gravity-warning">GRAVITY<br>REVERSED!!</div>

    <canvas id="game-canvas"></canvas>

    <script>
        const Engine = Matter.Engine,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite,
              Constraint = Matter.Constraint,
              Events = Matter.Events;

        let engine, runner, world;
        let marbles = [], particles = [], finishedMarbles = [], sweepers = [], mines = [], luckyBoxes = [], blackholes = [];
        let gravitySwitch = null;
        
        const MAP_WIDTH = 1600;
        const MAP_HEIGHT = 12000;
        const FINISH_LINE = MAP_HEIGHT - 300;
        
        let cameraY = 0;
        let cameraZoom = 1; 
        
        let isGravityReversed = false;
        let gravityTimer = 0;
        const GRAVITY_DURATION = 180; // 3ì´ˆ
        const BASE_GRAVITY = 1.8;
        
        let totalPlayers = 0;
        let numLosers = 0;

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const colors = ['#00ffff', '#ff00ff', '#00ff00', '#ffff00', '#ff5500', '#0088ff', '#ff0055', '#aaff00', '#ffffff', '#ff8800', '#ffb0b0', '#b0ffb0'];

        // ì°¸ê°€ì ì…ë ¥ì— ë”°ë¥¸ ì»¤í”¼ ë‹¹ì²¨ì ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
        document.getElementById('players-input').addEventListener('input', (e) => {
            let count = e.target.value.split(',').map(p => p.trim()).filter(p => p !== "").length;
            let losers = Math.max(1, Math.floor(count / 4));
            if(count === 0) losers = 0;
            document.getElementById('penalty-info').innerText = `â˜• ì»¤í”¼ ë‚´ê¸° ë‹¹ì²¨ì: ${losers}ëª… (ìë™ ê³„ì‚°)`;
        });

        function init() {
            engine = Engine.create();
            world = engine.world;
            world.gravity.y = BASE_GRAVITY; 

            handleResize();
            window.addEventListener('resize', handleResize);

            buildMap();

            runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'collisionStart', handleCollisions);
            Events.on(engine, 'collisionActive', handleActiveCollisions);
            Events.on(engine, 'beforeUpdate', updateLogic); 

            requestAnimationFrame(render);
        }

        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cameraZoom = Math.min(1.0, Math.max(0.3, window.innerWidth / (MAP_WIDTH + 400)));
        }

        function buildMap() {
            Composite.clear(world);
            Engine.clear(engine);
            marbles = []; finishedMarbles = []; particles = []; sweepers = []; mines = []; luckyBoxes = []; blackholes = [];
            gravitySwitch = null;
            cameraY = 0;
            isGravityReversed = false;
            world.gravity.y = BASE_GRAVITY;
            
            document.getElementById('gravity-warning').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';

            let elements = [];
            const wallOpts = { isStatic: true, label: 'wall', friction: 0, restitution: 0.6 };
            
            // ì™¸ê³½ ë²½
            elements.push(
                Bodies.rectangle(-50, MAP_HEIGHT/2, 100, MAP_HEIGHT + 1000, wallOpts),
                Bodies.rectangle(MAP_WIDTH + 50, MAP_HEIGHT/2, 100, MAP_HEIGHT + 1000, wallOpts),
                Bodies.rectangle(MAP_WIDTH/2, MAP_HEIGHT + 100, MAP_WIDTH, 200, wallOpts)
            );

            // ğŸš« ë¬´ì‘ìœ„ ê°€ë“œë ˆì¼ (ë²½íƒ€ê¸° ê¼¼ìˆ˜ ë°©ì§€)
            for(let y = 800; y < MAP_HEIGHT - 1000; y += 400 + Math.random() * 400) {
                elements.push(Bodies.rectangle(50, y, 250 + Math.random()*100, 40, { isStatic: true, angle: Math.PI/5, friction: 0, restitution: 0.8, label: 'wall', chamfer: {radius: 15} }));
                elements.push(Bodies.rectangle(MAP_WIDTH - 50, y + 200, 250 + Math.random()*100, 40, { isStatic: true, angle: -Math.PI/5, friction: 0, restitution: 0.8, label: 'wall', chamfer: {radius: 15} }));
            }

            // ğŸ² [ì„¹ì…˜ 1] ì™„ì „ ë¬´ì‘ìœ„ ì§€ê·¸ì¬ê·¸ ë§‰ëŒ€ê¸° 
            let startY = 300;
            const numSticks = 5 + Math.floor(Math.random() * 4); // 5~8ê°œ
            for (let i = 0; i < numSticks; i++) {
                let y = startY + (i * (250 + Math.random() * 150));
                let isLeft = Math.random() > 0.5;
                let width = 400 + Math.random() * 500;
                let x = (isLeft ? 0 : MAP_WIDTH) + (isLeft ? width/2 : -width/2) + (Math.random()*200 - 100);
                let angle = (0.15 + Math.random() * 0.3) * (isLeft ? 1 : -1);
                
                let rect = Bodies.rectangle(x, y, width, 40, { isStatic: true, angle: angle, friction: 0, restitution: 0.3, label: 'wall', chamfer: { radius: 20 } });
                elements.push(rect);
                
                if (Math.random() > 0.5) {
                    let mineX = isLeft ? x + width/2 - 40 : x - width/2 + 40;
                    let mine = Bodies.circle(mineX, y - 40, 20, { isStatic: true, isSensor: true, label: 'mine' });
                    elements.push(mine); mines.push(mine);
                }
            }

            // ğŸ² [ì„¹ì…˜ 2] ìì´ì–¸íŠ¸ ì‹œì†Œ & ë¬´ë¹™ ìŠ¤ìœ„í¼ (í˜¼í•©)
            let midY = 3000;
            const numMidObstacles = 8 + Math.floor(Math.random() * 5);
            for(let i = 0; i < numMidObstacles; i++) {
                let y = midY + (i * 350);
                let x = MAP_WIDTH/2 + (Math.random()*400 - 200);
                
                if (Math.random() > 0.4) { // ì‹œì†Œ
                    let seesaw = Bodies.rectangle(x, y, 400 + Math.random()*200, 40, { friction: 0, restitution: 0.2, label: 'seesaw', chamfer: { radius: 20 }});
                    Matter.Body.setAngle(seesaw, (Math.random()*0.4 - 0.2)); 
                    let pivot = Constraint.create({ pointA: {x, y}, bodyB: seesaw, length: 0, stiffness: 0.9, render: { visible: false } });
                    elements.push(seesaw, pivot);
                    elements.push(Bodies.circle(x - 250, y - 50, 15, { isStatic: true, label: 'pin' }), Bodies.circle(x + 250, y - 50, 15, { isStatic: true, label: 'pin' }));
                } else { // ë¬´ë¹™ ìŠ¤ìœ„í¼
                    let sweeper = Bodies.rectangle(x, y, 300 + Math.random()*150, 40, { isStatic: true, friction: 0, restitution: 0.8, label: 'wall', chamfer: { radius: 20 } });
                    elements.push(sweeper);
                    sweepers.push({ body: sweeper, startX: x, range: 250 + Math.random()*150, angle: Math.random() * Math.PI, speed: 0.03 + Math.random()*0.04 });
                }

                // ë¬´ì‘ìœ„ ì•„ì´í…œ
                if (Math.random() > 0.6) {
                    let box = Bodies.rectangle(x + (Math.random()*300 - 150), y - 80, 50, 50, { isStatic: true, isSensor: true, label: 'lucky_box', chamfer: {radius: 8} });
                    elements.push(box); luckyBoxes.push(box);
                }
            }

            // ğŸ² [ì„¹ì…˜ 3] ë¬´ì‘ìœ„ ë¸”ë™í™€ & ë¶€ìŠ¤í„°
            let bhY = 6000;
            const numBH = 2 + Math.floor(Math.random() * 2);
            for(let i=0; i<numBH; i++) {
                let x = MAP_WIDTH/2 + (Math.random()*800 - 400);
                let y = bhY + (i * 800) + Math.random()*300;
                createBlackhole(elements, x, y, 400 + Math.random()*300, 0.005 + Math.random()*0.003);
            }

            for(let i=0; i < 5 + Math.random()*3; i++) {
                let x = 200 + Math.random() * (MAP_WIDTH - 400);
                let y = 6000 + Math.random() * 3000;
                let pad = Bodies.rectangle(x, y, 200 + Math.random()*100, 30, { isStatic: true, isSensor: true, label: 'boost', chamfer: { radius: 10 } });
                elements.push(pad);
            }

            // ğŸš¨ [ì„¹ì…˜ 4] ëŒ€ë§ì˜ ê·¹í›„ë°˜ 'ì¤‘ë ¥ ë°˜ì „ ìŠ¤ìœ„ì¹˜' (9500 ë¶€ê·¼ ë°°ì¹˜)
            let switchY = 9300 + Math.random() * 500;
            gravitySwitch = Bodies.rectangle(MAP_WIDTH/2, switchY, 800 + Math.random()*400, 50, { isStatic: true, isSensor: true, label: 'gravity_switch', chamfer: {radius: 20} });
            elements.push(gravitySwitch);

            // ğŸ² [ì„¹ì…˜ 5] ê·¹í›„ë°˜ ë‚œì „ìš© ë¬´ì‘ìœ„ í”Œë§ì½” í•€ë³¼ & ì§€ë¢°ë°­
            for (let y = switchY + 300; y < 11200; y += 180 + Math.random()*100) {
                let offset = (Math.random() > 0.5) ? 0 : 90;
                for (let x = 100; x < MAP_WIDTH - 50; x += 180 + Math.random()*50) {
                    let rand = Math.random();
                    if (rand > 0.2) {
                        elements.push(Bodies.circle(x + offset, y, 15 + Math.random()*10, { isStatic: true, restitution: 0.6, label: 'pin' }));
                    } else if (rand > 0.05) {
                        let mine = Bodies.circle(x + offset, y, 20, { isStatic: true, isSensor: true, label: 'mine' });
                        elements.push(mine); mines.push(mine);
                    }
                }
            }

            // ğŸ [ì„¹ì…˜ 6] ê²°ìŠ¹ì„  ì¹¸ë§‰ì´
            const numSlots = 10;
            const slotWidth = MAP_WIDTH / numSlots;
            for (let i = 1; i < numSlots; i++) {
                let dividerX = i * slotWidth;
                let dividerY = MAP_HEIGHT - 300;
                let divider = Bodies.rectangle(dividerX, dividerY, 20, 600, { isStatic: true, restitution: 0.5, label: 'wall' });
                let cap = Bodies.circle(dividerX, dividerY - 300, 10, { isStatic: true, restitution: 0.5, label: 'wall' });
                elements.push(divider, cap);
            }

            Composite.add(world, elements);
        }

        function createBlackhole(elementsArray, x, y, radius, power) {
            let bhSensor = Bodies.circle(x, y, radius, { isStatic: true, isSensor: true, label: 'blackhole_sensor' });
            let bhCore = Bodies.circle(x, y, radius * 0.1, { isStatic: true, restitution: 0.8, friction: 0, label: 'blackhole_core' });
            elementsArray.push(bhSensor, bhCore);
            blackholes.push({ x: x, y: y, radius: radius, power: power, rotation: 0 });
        }

        function startRace(playerNames) {
            if(marbles.length > 0) buildMap();
            
            totalPlayers = playerNames.length;
            numLosers = Math.max(1, Math.floor(totalPlayers / 4)); // ìµœì†Œ 1ëª…ì€ ì»¤í”¼!

            document.getElementById('ui-panel').style.transform = 'translateY(-150%)';
            document.getElementById('leaderboard').style.display = 'block';

            playerNames.forEach((name, i) => {
                const color = colors[i % colors.length];
                const startX = (MAP_WIDTH / 2) + (Math.random() * 600 - 300);
                const startY = -300 - (Math.random() * 200);
                
                const marble = Bodies.circle(startX, startY, 24, { 
                    restitution: 0.6, 
                    friction: 0.001,
                    frictionAir: 0.015,
                    density: 0.05,
                    label: 'marble',
                    plugin: { 
                        name: name, color: color, trail: [], finished: false, rank: 0, 
                        stuckTimer: 0, effect: 'none', effectTimer: 0, baseRadius: 24
                    }
                });
                
                Body.setVelocity(marble, { x: (Math.random() - 0.5) * 15, y: 5 });
                marbles.push(marble);
                Composite.add(world, marble);
            });
        }

        function triggerMine(mineBody, triggerMarble) {
            Body.setPosition(mineBody, { x: -1000, y: -1000 });
            createParticles(mineBody.position.x, mineBody.position.y, '#ff0055', 80, 30); 

            const explosionRadius = 300;
            const explosionForce = 0.6;

            marbles.forEach(marble => {
                let dx = marble.position.x - mineBody.position.x;
                let dy = marble.position.y - mineBody.position.y;
                let distSq = dx*dx + dy*dy;

                if (distSq < explosionRadius * explosionRadius) {
                    let dist = Math.sqrt(distSq);
                    let forceMag = explosionForce * (1 - dist/explosionRadius) * marble.mass;
                    Body.applyForce(marble, marble.position, { x: (dx/dist) * forceMag, y: (dy/dist) * forceMag - 0.3 });
                }
            });
        }

        function triggerLuckyBox(boxBody, marble) {
            Body.setPosition(boxBody, { x: -1000, y: -1000 });
            const effects = ['giant', 'mini', 'freeze'];
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            marble.plugin.effect = effect;
            
            if (effect === 'giant') {
                marble.plugin.effectTimer = 400; 
                Body.scale(marble, 2.5, 2.5); Body.setDensity(marble, 0.2); 
                createParticles(marble.position.x, marble.position.y, '#ffff00', 50);
            } 
            else if (effect === 'mini') {
                marble.plugin.effectTimer = 400;
                Body.scale(marble, 0.5, 0.5); Body.setDensity(marble, 0.05); 
                createParticles(marble.position.x, marble.position.y, '#00ffff', 50);
            }
            else if (effect === 'freeze') {
                marble.plugin.effectTimer = 120; 
                marble.plugin.savedVelocity = { ...marble.velocity };
                Body.setVelocity(marble, {x:0, y:0}); Body.setStatic(marble, true); 
                createParticles(marble.position.x, marble.position.y, '#ffffff', 50);
            }
        }

        function triggerGravitySwitch() {
            if (isGravityReversed) return; 
            isGravityReversed = true;
            gravityTimer = GRAVITY_DURATION;
            world.gravity.y = -BASE_GRAVITY; 
            document.getElementById('gravity-warning').style.display = 'block';
            createParticles(gravitySwitch.position.x, gravitySwitch.position.y, '#ff0000', 150, 50);
        }

        // ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸ ë¡œì§ (í•µì‹¬: ê³ ë¬´ì¤„ íš¨ê³¼ ì ìš©)
        function updateLogic() {
            // ë¬´ë¹™ ë²½ ì´ë™
            sweepers.forEach(s => {
                s.angle += s.speed;
                let nx = s.startX + Math.sin(s.angle) * s.range;
                Body.setPosition(s.body, { x: nx, y: s.body.position.y });
            });

            // ë¸”ë™í™€ ì¸ë ¥
            blackholes.forEach(bh => {
                bh.rotation += 0.08; 
                marbles.forEach(marble => {
                    if (marble.plugin.finished) return;
                    let dx = bh.x - marble.position.x;
                    let dy = bh.y - marble.position.y;
                    let distSq = dx*dx + dy*dy;
                    if (distSq < bh.radius * bh.radius) {
                        let dist = Math.sqrt(distSq);
                        if (dist > 15) {
                            let massFactor = marble.plugin.effect === 'giant' ? 0.6 : 1.0;
                            let forceMag = bh.power * marble.mass * massFactor * (1 - dist/bh.radius); 
                            let nx = dx / dist; let ny = dy / dist;
                            let vx = nx * 1.5 + ny * 0.8; let vy = ny * 1.5 - nx * 0.8;
                            Body.applyForce(marble, marble.position, { x: vx * forceMag, y: vy * forceMag });
                        }
                    }
                });
            });

            // ğŸ§² ê³ ë¬´ì¤„ íš¨ê³¼ (Rubber-Banding) - ìˆœìœ„ë¥¼ ì¢í˜€ì£¼ëŠ” í•µì‹¬ ë¡œì§
            let activeMarbles = marbles.filter(m => !m.plugin.finished);
            if (activeMarbles.length > 1) {
                // ì„ ë‘(ê°€ì¥ ë‚®ì€ ê³³) Yê°’ ê³„ì‚°
                let leaderY = isGravityReversed 
                    ? Math.min(...activeMarbles.map(m => m.position.y)) 
                    : Math.max(...activeMarbles.map(m => m.position.y));

                activeMarbles.forEach(marble => {
                    if (marble.plugin.effect === 'freeze') return;

                    // ì„ ë‘ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
                    let distFromLeader = isGravityReversed 
                        ? (marble.position.y - leaderY) 
                        : (leaderY - marble.position.y);

                    // 1ë“±ê³¼ ê±°ë¦¬ê°€ 400 ì´ìƒ ë²Œì–´ì§€ë©´ ë’¤ì—ì„œ ë°€ì–´ì£¼ëŠ” ê°€ì†ë„(Catch-up force) ë¶€ì—¬
                    if (distFromLeader > 400) {
                        // ë©€ì–´ì§ˆìˆ˜ë¡ ê°•í•˜ê²Œ ë‹¹ê¹€ (ë‹¨, ìµœëŒ€ì¹˜ ì œí•œ)
                        let catchUpPower = Math.min(distFromLeader * 0.000015, 0.03) * marble.mass;
                        Body.applyForce(marble, marble.position, {
                            x: 0, 
                            y: isGravityReversed ? -catchUpPower : catchUpPower
                        });
                    }

                    // 1ë“± ê·¸ë£¹ì—ê²ŒëŠ” ì•½ê°„ì˜ ì €í•­(Drag)ì„ ì£¼ì–´ ë…ì£¼ ë°©ì§€
                    if (distFromLeader < 100 && activeMarbles.length > 2) {
                        let drag = 0.005 * marble.mass;
                        Body.applyForce(marble, marble.position, {
                            x: 0,
                            y: isGravityReversed ? drag : -drag
                        });
                    }
                });
            }

            // ì¤‘ë ¥ ë°˜ì „ íƒ€ì´ë¨¸
            if (isGravityReversed) {
                gravityTimer--;
                if (gravityTimer <= 0) {
                    isGravityReversed = false;
                    world.gravity.y = BASE_GRAVITY; 
                    document.getElementById('gravity-warning').style.display = 'none';
                } else {
                    document.getElementById('gravity-warning').style.opacity = (gravityTimer % 10 < 5) ? 1 : 0.5;
                }
            }

            marbles.forEach(marble => {
                if (marble.plugin.finished) return;

                // ë¼ì„ ë°©ì§€ íƒˆì¶œ
                if (marble.plugin.effect !== 'freeze' && Math.abs(marble.velocity.x) < 0.5 && Math.abs(marble.velocity.y) < 0.5) {
                    marble.plugin.stuckTimer++;
                    if (marble.plugin.stuckTimer > 30) {
                        Body.applyForce(marble, marble.position, { x: (Math.random() - 0.5) * 0.2 * marble.mass, y: (isGravityReversed ? 0.3 : -0.3) * marble.mass });
                        marble.plugin.stuckTimer = 0;
                    }
                } else {
                    marble.plugin.stuckTimer = 0;
                }

                // íŠ¹ìˆ˜ íš¨ê³¼ í•´ì œ íƒ€ì´ë¨¸
                if (marble.plugin.effect !== 'none') {
                    marble.plugin.effectTimer--;
                    if (marble.plugin.effectTimer <= 0) {
                        if (marble.plugin.effect === 'giant') { Body.scale(marble, 1/2.5, 1/2.5); Body.setDensity(marble, 0.05); } 
                        else if (marble.plugin.effect === 'mini') { Body.scale(marble, 2, 2); } 
                        else if (marble.plugin.effect === 'freeze') { Body.setStatic(marble, false); Body.setVelocity(marble, marble.plugin.savedVelocity); }
                        marble.plugin.effect = 'none';
                        createParticles(marble.position.x, marble.position.y, marble.plugin.color, 30);
                    }
                }
            });
        }

        function handleCollisions(event) {
            event.pairs.forEach(pair => {
                if (pair.bodyA.label === 'blackhole_core' || pair.bodyB.label === 'blackhole_core') {
                    let marble = pair.bodyA.label === 'marble' ? pair.bodyA : (pair.bodyB.label === 'marble' ? pair.bodyB : null);
                    if(marble) createParticles(marble.position.x, marble.position.y, '#a020f0', 10);
                }
            });
        }

        function handleActiveCollisions(event) {
            event.pairs.forEach(pair => {
                let marble = pair.bodyA.label === 'marble' ? pair.bodyA : (pair.bodyB.label === 'marble' ? pair.bodyB : null);
                let sensor = pair.bodyA.isSensor ? pair.bodyA : (pair.bodyB.isSensor ? pair.bodyB : null);

                if (marble && sensor) {
                    if (sensor.label === 'boost') {
                        Body.applyForce(marble, marble.position, { x: 0, y: 0.1 * (marble.mass / 0.09) * (isGravityReversed ? -1 : 1) }); 
                        createParticles(marble.position.x, marble.position.y - 20, '#0f0', 3);
                    } 
                    else if (sensor.label === 'mine') triggerMine(sensor, marble);
                    else if (sensor.label === 'lucky_box' && marble.plugin.effect === 'none') triggerLuckyBox(sensor, marble);
                    else if (sensor.label === 'gravity_switch') { triggerGravitySwitch(); Body.setPosition(sensor, {x: -1000, y: -1000}); }
                }
            });
        }

        function createParticles(x, y, color, count, speed=20) {
            for(let i=0; i<count; i++) particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed, life: 1.0, color: color });
        }

        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath();
        }

        function render() {
            if (isGravityReversed) ctx.fillStyle = 'rgba(50, 0, 0, 1)';
            else ctx.fillStyle = '#080811';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let leaderY = isGravityReversed ? MAP_HEIGHT : 0; 
            marbles.forEach(m => {
                if (!m.plugin.finished) {
                    if (!isGravityReversed && m.position.y > leaderY) leaderY = m.position.y;
                    if (isGravityReversed && m.position.y < leaderY) leaderY = m.position.y;
                }
            });
            if (!isGravityReversed && leaderY === 0 && finishedMarbles.length > 0) leaderY = MAP_HEIGHT; 

            let viewHeightInWorld = canvas.height / cameraZoom;
            let targetCameraY = isGravityReversed ? leaderY - (viewHeightInWorld * 0.3) : leaderY - (viewHeightInWorld * 0.7); 
            if (targetCameraY < -500) targetCameraY = -500;
            if (targetCameraY > MAP_HEIGHT - viewHeightInWorld + 200) targetCameraY = MAP_HEIGHT - viewHeightInWorld + 200;
            cameraY += (targetCameraY - cameraY) * 0.1;

            ctx.save();
            ctx.translate(canvas.width / 2, 0); ctx.scale(cameraZoom, cameraZoom); ctx.translate(-MAP_WIDTH / 2, -cameraY);

            // 1. ë¸”ë™í™€
            blackholes.forEach(bh => {
                let gradient = ctx.createRadialGradient(bh.x, bh.y, bh.radius * 0.1, bh.x, bh.y, bh.radius);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)'); gradient.addColorStop(0.3, 'rgba(128, 0, 255, 0.5)'); gradient.addColorStop(1, 'rgba(128, 0, 255, 0)');
                ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(bh.x, bh.y, bh.radius, 0, 2 * Math.PI); ctx.fill();

                ctx.save(); ctx.translate(bh.x, bh.y); ctx.rotate(bh.rotation);
                ctx.strokeStyle = 'rgba(200, 100, 255, 0.6)'; ctx.lineWidth = 3;
                for(let i=0; i<8; i++) { ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(bh.radius * 0.6, bh.radius * 0.6, bh.radius, 0); ctx.stroke(); ctx.rotate((Math.PI * 2) / 8); }
                ctx.restore();
                
                ctx.fillStyle = '#000'; ctx.strokeStyle = '#a020f0'; ctx.lineWidth = 4; ctx.shadowColor = '#a020f0'; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(bh.x, bh.y, bh.radius * 0.1, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
            });

            // 2. ì¼ë°˜ ë²½
            ctx.fillStyle = 'rgba(0, 240, 255, 0.1)'; ctx.strokeStyle = '#00f0ff'; ctx.lineWidth = 3;
            world.bodies.forEach(body => {
                if (body.label === 'wall' || body.label === 'seesaw') {
                    ctx.beginPath();
                    body.parts.forEach((part, i) => {
                        if (i === 0 && body.parts.length > 1) return; 
                        ctx.moveTo(part.vertices[0].x, part.vertices[0].y);
                        for (let j = 1; j < part.vertices.length; j++) ctx.lineTo(part.vertices[j].x, part.vertices[j].y);
                        ctx.lineTo(part.vertices[0].x, part.vertices[0].y);
                    });
                    ctx.fill(); ctx.stroke();
                }
            });

            // 3. íŠ¹ìˆ˜ ê°ì²´
            let bounce = Math.sin(Date.now() / 200) * 5;
            world.bodies.forEach(body => {
                if (body.label === 'boost') {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; ctx.strokeStyle = '#0f0'; ctx.lineWidth = 4; ctx.shadowColor = '#0f0'; ctx.shadowBlur = 15;
                    ctx.beginPath(); body.vertices.forEach((v, i) => i===0 ? ctx.moveTo(v.x, v.y) : ctx.lineTo(v.x, v.y)); ctx.closePath();
                    ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#0f0'; ctx.font = 'bold 35px Arial'; ctx.textAlign = 'center'; ctx.fillText('â†“â†“ BOOST â†“â†“', body.position.x, body.position.y + 12);
                } 
                else if (body.label === 'lucky_box') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    let hue = (Date.now() / 10) % 360; ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`; ctx.lineWidth = 4; ctx.shadowColor = ctx.strokeStyle; ctx.shadowBlur = 20;
                    drawRoundRect(ctx, body.bounds.min.x, body.bounds.min.y + bounce, 50, 50, 8); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 35px Arial'; ctx.textAlign = 'center'; ctx.fillText('?', body.position.x, body.position.y + 12 + bounce);
                }
                else if (body.label === 'mine') {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 3; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.arc(body.position.x, body.position.y, body.circleRadius + bounce*0.5, 0, 2*Math.PI); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.fillText('âŒ', body.position.x, body.position.y + 8);
                }
                else if (body.label === 'gravity_switch') {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.5)'; ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 8; ctx.shadowColor = '#ff0055'; ctx.shadowBlur = 30 + bounce*2;
                    drawRoundRect(ctx, body.bounds.min.x, body.bounds.min.y, body.bounds.max.x - body.bounds.min.x, 50, 15); ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff'; ctx.font = '900 35px "Malgun Gothic"'; ctx.textAlign = 'center'; ctx.fillText('âš ï¸ ì¤‘ë ¥ ë°˜ì „ ìŠ¤ìœ„ì¹˜ âš ï¸', body.position.x, body.position.y + 15);
                }
            });

            // 4. í•€
            world.bodies.forEach(body => {
                if (body.label === 'pin') {
                    ctx.beginPath(); ctx.arc(body.position.x, body.position.y, body.circleRadius, 0, 2*Math.PI);
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.2)'; ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 3; ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 10;
                    ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
                }
            });

            // ê²°ìŠ¹ì„ 
            ctx.beginPath(); ctx.moveTo(0, FINISH_LINE); ctx.lineTo(MAP_WIDTH, FINISH_LINE);
            ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 10; ctx.setLineDash([30, 20]); ctx.stroke(); ctx.setLineDash([]);
            ctx.fillStyle = '#ffff00'; ctx.font = 'bold 60px sans-serif'; ctx.textAlign = 'center'; 
            ctx.fillText('ğŸ† FINISH LINE ğŸ†', MAP_WIDTH/2, FINISH_LINE - 30);

            // íŒŒí‹°í´
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.02;
                if (p.life <= 0) { particles.splice(i, 1); continue; }
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 8, 8); 
            }
            ctx.globalAlpha = 1.0;

            // 5. ë§ˆë¸” ë Œë”ë§
            updateLeaderboard();

            marbles.forEach(marble => {
                const plugin = marble.plugin;
                
                // ê²°ìŠ¹ì„  í†µê³¼ ì²˜ë¦¬
                if (!plugin.finished && marble.position.y > FINISH_LINE) {
                    plugin.finished = true;
                    plugin.rank = finishedMarbles.length + 1;
                    finishedMarbles.push(marble);
                    createParticles(marble.position.x, marble.position.y, plugin.color, 80);
                    
                    if(finishedMarbles.length === marbles.length) {
                        setTimeout(() => document.getElementById('ui-panel').style.transform = 'translateY(0)', 3000);
                    }
                }

                if (plugin.effect !== 'freeze') plugin.trail.push({x: marble.position.x, y: marble.position.y});
                if (plugin.trail.length > 25) plugin.trail.shift();

                if (plugin.trail.length > 1) {
                    ctx.beginPath(); ctx.moveTo(plugin.trail[0].x, plugin.trail[0].y);
                    for (let i=1; i<plugin.trail.length; i++) ctx.lineTo(plugin.trail[i].x, plugin.trail[i].y);
                    ctx.lineWidth = marble.circleRadius * 1.5; ctx.lineCap = 'round';
                    let gradient = ctx.createLinearGradient(plugin.trail[0].x, plugin.trail[0].y, plugin.trail[plugin.trail.length-1].x, plugin.trail[plugin.trail.length-1].y);
                    gradient.addColorStop(0, 'rgba(0,0,0,0)'); gradient.addColorStop(1, plugin.color);
                    ctx.strokeStyle = gradient; ctx.stroke();
                }

                if (plugin.effect === 'giant') {
                    ctx.beginPath(); ctx.arc(marble.position.x, marble.position.y, marble.circleRadius * 1.3, 0, 2*Math.PI);
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'; ctx.fill();
                } else if (plugin.effect === 'freeze') {
                    ctx.beginPath(); ctx.arc(marble.position.x, marble.position.y, marble.circleRadius * 1.5, 0, 2*Math.PI);
                    ctx.fillStyle = 'rgba(200, 255, 255, 0.6)'; ctx.fill(); 
                }

                ctx.beginPath(); ctx.arc(marble.position.x, marble.position.y, marble.circleRadius, 0, 2*Math.PI);
                ctx.fillStyle = (plugin.effect === 'freeze') ? '#ccffff' : '#fff'; ctx.fill();
                ctx.strokeStyle = plugin.color; ctx.lineWidth = 6;
                ctx.shadowColor = plugin.color; ctx.shadowBlur = (plugin.effect !== 'none') ? 50 : 30; ctx.stroke(); ctx.shadowBlur = 0;

                let fontSize = (plugin.effect === 'giant') ? 40 : (plugin.effect === 'mini' ? 18 : 28);
                ctx.font = `bold ${fontSize}px "Malgun Gothic", sans-serif`;
                const textWidth = ctx.measureText(plugin.name).width;
                const badgeWidth = textWidth + 24;
                const badgeHeight = (plugin.effect === 'giant') ? 50 : (plugin.effect === 'mini' ? 25 : 40);
                const badgeX = marble.position.x - badgeWidth / 2;
                const badgeY = marble.position.y - marble.circleRadius - badgeHeight - (plugin.effect === 'giant' ? 15 : 10);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                drawRoundRect(ctx, badgeX, badgeY, badgeWidth, badgeHeight, 10); ctx.fill();
                ctx.strokeStyle = plugin.color; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
                ctx.fillText(plugin.name, marble.position.x, badgeY + (plugin.effect === 'giant' ? 35 : (plugin.effect === 'mini' ? 18 : 28)));
                
                if (plugin.finished) {
                    // ì»¤í”¼ ë‚´ê¸° ë‹¹ì²¨ ì—¬ë¶€ í™•ì¸
                    const isLoser = plugin.rank > totalPlayers - numLosers;
                    const rankStr = isLoser ? 'â˜• ë‹¹ì²¨!' : plugin.rank + 'ë“±';
                    
                    ctx.font = '900 40px "Malgun Gothic", sans-serif';
                    const rWidth = ctx.measureText(rankStr).width;
                    
                    // ê¼´ë“±ì€ ë¶‰ì€ìƒ‰ ë°°ê²½ìœ¼ë¡œ ê°•ì¡°
                    ctx.fillStyle = isLoser ? 'rgba(200, 0, 0, 0.9)' : 'rgba(0, 0, 0, 0.8)';
                    drawRoundRect(ctx, marble.position.x - rWidth/2 - 20, marble.position.y - marble.circleRadius - 110, rWidth + 40, 50, 10);
                    ctx.fill();
                    ctx.fillStyle = isLoser ? '#ffffff' : 'gold'; 
                    ctx.fillText(rankStr, marble.position.x, marble.position.y - marble.circleRadius - 70);
                }
            });

            ctx.restore();
            requestAnimationFrame(render);
        }

        function updateLeaderboard() {
            if(marbles.length === 0) return;
            let sorted = [...marbles].sort((a, b) => {
                if (a.plugin.finished && b.plugin.finished) return a.plugin.rank - b.plugin.rank;
                if (a.plugin.finished) return -1;
                if (b.plugin.finished) return 1;
                return b.position.y - a.position.y;
            });

            let html = '';
            sorted.forEach((marble, idx) => {
                const rank = idx + 1;
                let cssClass = 'rank-item';
                
                // ì»¤í”¼ ë‹¹ì²¨ì ë¦¬ìŠ¤íŠ¸ ì‹œê° íš¨ê³¼
                const isLoser = marble.plugin.finished && marble.plugin.rank > totalPlayers - numLosers;
                
                if (isLoser) cssClass += ' rank-loser';
                else if (rank === 1) cssClass += ' rank-1';
                else if (rank === 2) cssClass += ' rank-2';
                else if (rank === 3) cssClass += ' rank-3';

                let status = marble.plugin.finished ? (isLoser ? 'â˜• ì»¤í”¼!' : 'ğŸ í†µê³¼') : Math.floor((marble.position.y / FINISH_LINE) * 100) + '%';
                if(marble.position.y < 0) status = 'ëŒ€ê¸°ì¤‘';

                let icon = '';
                if(marble.plugin.effect === 'giant') icon = 'ğŸ„';
                else if(marble.plugin.effect === 'mini') icon = 'ğŸ­';
                else if(marble.plugin.effect === 'freeze') icon = 'ğŸ¥¶';

                html += `<div class="${cssClass}">
                            <div style="display:flex; align-items:center;">
                                <span style="display:inline-block; width:25px; font-size:1.1em; text-align:center; margin-right:10px;">${rank}</span>
                                <span style="display:inline-block; width:14px; height:14px; border-radius:50%; background-color:${marble.plugin.color}; margin-right:10px; box-shadow:0 0 8px ${marble.plugin.color}"></span>
                                <span>${marble.plugin.name} ${icon}</span>
                            </div>
                            <span class="text-sm ${isLoser ? 'text-red-300' : 'text-gray-300'}">${status}</span>
                         </div>`;
            });
            document.getElementById('rank-list').innerHTML = html;
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            const players = document.getElementById('players-input').value.split(',').map(p => p.trim()).filter(p => p !== "");
            if (players.length > 0) startRace(players);
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            buildMap();
            document.getElementById('ui-panel').style.transform = 'translateY(0)';
        });

        init();
    </script>
</body>
</html>
